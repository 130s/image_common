/**
\mainpage
\htmlinclude manifest.html

When working with images we often want specialized transport strategies,
such as using image compression or streaming video codecs. image_transport
provides classes and nodes for transporting images in arbitrary over-the-wire
representations, while abstracting this complexity so that the developer only
sees sensor_msgs/Image messages.

Specialized transports are provided by plugins. image_transport itself provides
only "raw" transport so as not to not impose unnecessary dependencies on client
packages. To make other transports available, you must explicitly build their
packages. Use \ref list_transports to see what transports are available and
diagnose issues.


\section codeapi Code API
When transporting images, you should use image_transport's classes as drop-in
replacements for ros::Publisher and ros::Subscriber.
- image_transport::ImageTransport - use this to create a Publisher or Subscriber
- image_transport::Publisher - manage advertisements for an image topic, using all available transport options
- image_transport::Subscriber - manage an Image subscription callback using a particular transport

Camera drivers publish a "camera_info" sibling topic containing important metadata on how to
interpret an image for vision applications. image_transport included helper classes to
publish (image, info) message pairs and re-synchronize them on the client side:
- image_transport::CameraPublisher - manage advertisements for camera images
- image_transport::CameraSubscriber - manage a single subscription callback to synchronized image (using any transport) and CameraInfo topics

For other synchronization or filtering needs, see the low-level filter class:
- image_transport::SubscriberFilter - a wrapper for image_transport::Subscriber compatible with message_filters

\subsection writing_plugin Writing a plugin
If you are an advanced user implementing your own image transport option, you will need to
implement these base-level interfaces:
- image_transport::PublisherPlugin
- image_transport::SubscriberPlugin

In the common case that all communication between PublisherPlugin and SubscriberPlugin happens
over a single ROS topic using a transport-specific message type, writing the plugins is vastly
simplified by using these base classes instead:
- image_transport::SimplePublisherPlugin - see image_transport::RawPublisher for a trivial example
- image_transport::SimpleSubscriberPlugin - see image_transport::RawSubscriber for a trivial example

\section rosapi ROS API

\subsection pub_sub_rosapi Publishers and Subscribers

Because they encapsulate complicated communication behavior, image_transport publisher
and subscriber classes have a public ROS API as well as a code API.

\subsubsection pub_sub_topics ROS topics

The image_transport classes use a standard naming convention for
topics. All interfaces take only a "base topic"
name, on which the raw Image is published (just as with ros::Publisher).
If additional plugins are available, they advertise subtopics of the base topic
treated as a namespace. For example, if the base topic is "/stereo/left/image",
the topic structure looks like:
\verbatim
# Base topic, advertised just as if we used ros::Publisher:
/stereo/left/image            # type sensor_msgs/Image

# Additionally advertised by image_transport::Publisher, if plugins are available:
/stereo/left/image/           # namespace of other image transport options
                   compressed # Each plugin publishes to <base topic>/<transport name>,
                   theora     # using a plugin-specific message data type.
                   ...

# Additionally published by image_transport::CameraPublisher:
/stereo/left/camera_info      # info topic, type sensor_msgs/CameraInfo
\endverbatim

\subsubsection pub_sub_parameters ROS parameters

image_transport::Subscriber reads from the parameter server:

- \b "~image_transport" : \b [string] name of the transport to use

If this parameter is not set, the transport from the image_transport::TransportHints
argument of image_transport::ImageTransport::subscribe() is used.

image_transport::TransportHints may be used to specify a different namespace for
parameter lookup. This is useful to push "image_transport" into separate namespaces
to allow different transports for different image subscriptions. The node writer may
even specify a parameter name other than "image_transport", although this is
discouraged for the sake of consistency. Nodes that subscribe to image topics should
document what parameter(s) control transport, especially if different from
"~image_transport".

Publisher and subscriber plugins are permitted to make use of the parameter server for
configuration options, e.g. bit rate, compression level, etc. See the plugin package
documentation.

@todo example launch file

*/
